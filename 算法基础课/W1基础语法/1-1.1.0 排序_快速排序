l， r
i = l - 1
j = r + 1
do while
x = q[l+r>>1] / q[l+r+1>>1]
循环跳出条件为 l >= r
排序停止条件   
  j之后的所有数（不包括j） >= x
  i之前的所有数（不包括i） <= x

为什么使用do while循环而不是while循环
  使用do while循环可以保证指针至少移动一次，从而保证上一轮递归中交换的数被遍历过去


关于边界的问题
  快速排序属于分治算法，划分失败的情况为 n分为 0 + n 或 n + 0，造成无线划分
    以j为划分的时候， x不能选为 q[r]  ==> x = q[l+r>>1]
    以i为划分的时候， x不能选为 q[l]  ==> x = q[l+r+1>>1]  (q,l,i-1)     (q,i,r)


区间以j为划分  (q,l,j)     (q,j+1,r)
  j经过do while循环后最大值为 r， 
  (q,l,j)， (q,j+1,r)， 区间等同为（q，l，r）  （q，r+1，r）[达到跳出循环的条件]
  若区间划分为(q,l,j-1)， (q,j,r)， 区间等同为（q，l，r-1）  （q，r，r）[为分治算法中划分失败的情况 n => n + 0]


区间以i为划分  (q,l,i-1)     (q,i,r)
  i经过do while循环后最小值为 l， 
  (q,l,i-1)， (q,i,r)， 区间等同为（q，l，l-1）[达到跳出循环的条件]   （q，l，r）
  若区间划分为(q,l,i)， (q,i+1,r)， 区间等同为（q，l，l）  （q，l+1，r）[为分治算法中划分失败的情况 n => 0 + n]
