思路:
通过trie树记录数的二进制表示


问题1: 如何取得在异或的条件下取得最大值:
  (xor)^ 按位异或  若参加运算的两个二进制位值相同则为0，否则为1
    EG: 数x1的二进制为 00110100, 能组成的最大数字为11111111, 对此与x1异或的数字为11001011

问题2: 如何寻找数字 X 异或取得最大值的对应数字:
  通过tri树从上至下遍历,在当前层,X的节点为x,寻找与节点x二进制值相反的节点,
    若相反的节点存在,则进入相反的节点,异或的结果的二进制表示的当前位为1
    若相反的节点不存在,则进入该结点,异或的结果的二进制表示的当前位为0




解析:
  输入数据<= 1e5, 数据值< 2e31
  const int N = 1e5 + 10, M = 30 * 1e5 + 10;
  int n, a[N], son[M][2], idx;
  a[N] 代表容纳输入的数据的数组
  son[M][2] 代表容纳输入的数据的二进制表示的数组

  i>= 0 与 ~i表示相同
    ~ 取反  ~是一元运算符，用来对一个二进制数按位取反，即将0变1，将1变0
    当i为 -1的时候,二进制表示为1111..11,取反为 0

  如何再寻值过程求得异或对的结果
    若当前层存在对应的需要寻找的数字, 二进制表示中, 将1 左移至当前的层数
    若当前层存在对应的需要寻找的数字, 二进制表示中, 将0 左移至当前的层数 //值不变,无操作意义吗,该操作可省略


  for(int i = 30; ~i; --i){
      int &s = son[p][x >> i & 1];
      if(!s) s = ++idx;
      p = s;
  }
  s为当前结点的引用,对s的判断和操作 即为对当前结点的判断和操作,
    若当前结点不存在,则创造结点,再向下执行
    若当前结点存在,则直接向下执行
