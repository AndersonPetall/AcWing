思路:
通过trie树,将每个输入的数字转换为30位的二进制表示,从最高位开始遍历

如何取得在异或的条件下取得最大值:
  (xor)^ 按位异或  若参加运算的两个二进制位值相同则为0，否则为1
    EG: 数x1的二进制为 00110100, 能组成的最大数字为11111111, 对此与x1异或的数字为11001011

如何寻找数字 X 异或取得最大值的对应数字:
  通过tri树从上至下遍历,在当前层,X的节点为x,寻找与节点x二进制值相反的节点,若相反的节点存在,则进入相反的节点,否则进入节点x


输入数据<= 1e5, 数据值< 2e31
const int N = 1e5 + 10, M = 30 * 1e5 + 10;
int n, a[N], son[M][2], idx;
a[N] 代表容纳输入的数据的数组
son[M][2] 代表容纳输入的数据的二进制表示的数组

i>= 0 与 ~i表示相同
  ~ 取反  ~是一元运算符，用来对一个二进制数按位取反，即将0变1，将1变0
  当i为 -1的时候,二进制表示为1111..11,取反为 0

若当前层存在对应的需要寻找的数字, 二进制表示中, 将1 左移至当前的层数
若当前层存在对应的需要寻找的数字, 二进制表示中, 将0 左移至当前的层数 //值不变,无操作意义吗,该操作可省略
