EG: 物品数量N = 4, 容量V = 4
 v1 = 1, w1 = 2
 v2 = 2, w2 = 4
 v3 = 2, w3 = 4
 v4 = 3, w4 = 5

for(int i=1;i<=n;++i)for(int j=1;j<=m;++j)f[i][j]= j < v[i] ? f[i-1][j] :max(f[i-1][j],f[i-1][j-v[i]]+w[i]);
i = 1 
  f[1][1] = max(f[0][1],f[0][0]+w[1]) = max(0,2) = 2
  f[1][2] = max(f[0][1],f[0][0]+w[1]) = max(0,2) = 2
  f[1][3] = max(f[0][1],f[0][0]+w[1]) = max(0,2) = 2
  f[1][4] = max(f[0][1],f[0][0]+w[1]) = max(0,2) = 2
i = 2
  f[2][1] = f[1][1] = 2
  f[2][2] = max(f[1][2],f[1][0]+w[2]) = max(2,4) = 4
  f[2][3] = max(f[1][3],f[1][1]+w[2]) = max(2,2+4) = 6
  f[2][4] = max(f[1][4],f[1][2]+w[2]) = max(2,2+4) = 6
i = 3
  f[3][1] = f[2][1] = 2
  f[3][2] = max(f[2][2],f[2][0]+w[3]) = max(4,4) = 4
  f[3][3] = max(f[2][3],f[2][1]+w[3]) = max(4,2+4) = 6
  f[3][4] = max(f[2][4],f[2][2]+w[3]) = max(4,4+4) = 8
i = 4
  f[4][1] = f[3][1] = 2
  f[4][2] = f[3][2] = 4
  f[4][3] = max(f[3][3],f[3][0]+w[4]) = max(6,0+5) = 6
  f[4][4] = max(f[3][4],f[3][1]+w[4]) = max(8,2+5) = 8     >> 答案
  



优化 滚动数组:一维数组 f[N][N] -> f[N]   保留上一次结果
原状态转移方程 
  for(int i=1;i<=n;++i)
    for(int j=1;j<=m;++j)  正序
      f[i][j]= max(f[i-1][j],f[i-1][j-v[i]]+w[i]);
  若变为一维数组 f[j] = max(f[j],f[j-v[i]]+w[i]);  则当前f[i][j]由第i轮的状态计算而来 -> f[i][j] = max(f[i][j],f[i][j-v[i]]+w[i]);
方法: 逆序枚举背包容量
  for(int i=1;i<=n;++i)
    for(int j=m;j>=v[i];--j)  逆序
      f[j]= max(f[j],f[j-v[i]]+w[i]);  当前f[i][j]由第i-1轮的状态计算而来

i = 1
  f[4] = max(f[4],f[3] + w[i]) = max(0,2) = 2
  f[3] = max(f[3],f[2] + w[i]) = max(0,2) = 2
  f[2] = max(f[2],f[1] + w[i]) = max(0,2) = 2
  f[1] = max(f[1],f[0] + w[i]) = max(0,2) = 2
i = 2
  f[4] = max(f[4],f[2] + w[i]) = max(2,2+4) = 6
  f[3] = max(f[3],f[1] + w[i]) = max(2,2+4) = 6
  f[2] = max(f[2],f[0] + w[i]) = max(2,0+4) = 4     
若为正序, i=2时,先计算f[2],后计算f[4], f[4]的状态由此轮(i=2)的f[2]的值进行计算  重复计算,违反题意
若为逆序, i=2时,先计算f[4],后计算f[2], f[4]的状态由上一轮轮(i=1)的f[2]的值进行计算
