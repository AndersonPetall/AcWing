目的: 在经过的边数有限的情况下,求最短路问题 ==> EG: 在不超过 K 条边的情况下,求最短路问题
  若存在负权边,没有边数的规定,则最短路问题不一定存在(路劲上有负环)  
  ==>  若在 K+X 条边的情况下,最短路问题有更新,则说明存在负环

基本思想
  for循环K次 
    for循环 遍历所有边 
      对于 a ==w==> b  更新 dis[b] = min(dis[b], dis[a] + w)   <==  松弛操作
  完成循环后,对于所有边必定满足 dis[b] <= dis[a] + w;    <==  三角不等式
  
      
WHY:  设置两个数组
问题: 如何判断在某次松弛操作中,所有点距离的更新所经过的路径的边数相同
现象: 如果一个有向边存在两次连续的松弛操作,即 dis[b] = min(dis[b], dis[a] + w), dis[b+1] = min(dis[b+1], dis[b] + w1)
        则意味着b号点经过的路劲边数为x, b+1号点经过的路劲边数为x + 1
解决: 设置两个数组,一个储存上次循环中得到的距离,一个计算当前循环中的距离


WHY:  判断条件为 dis[n] > 0x3f3f3f3f/2 
现象: 经过松弛操作,对于存在有向边的所有被指向的点,该点到源点的距离均会被更新
解释: 当有有向边的存在,该边的终点的距离会根据边的权重和该边的 dis[b] = min(dis[b], dis[a] + w)
解决: 最短路存在的判断条件为 0x3f3f3f3f/2 
      ==> 0x3f3f3f3f/2的数量级和0x3f3f3f3f一样, "/2"的目的是可能 存在路劲不通且N号点被松弛操作的情况
