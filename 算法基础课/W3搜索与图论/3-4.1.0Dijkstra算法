假设: n个点, m条边

朴素Dijkstra算法基本步骤:
  1.0 初始化距离,1号点确定为0, 其他点为正无穷
    dis[1] = 0, dis[others] = +++; 
  2.0 循环,每次确定一个距离最小的点
    S为已经确定的最短距离的点的集合
    for(i: 0-n)
      t <== 筛选出不在S中的,距离最近的点
      S <== t  将他加入到集合S中
      用t 来更新所有点的距离
        EG: 1号点 ==> t ==w==> x 
          if(dis[x] > dis[t] + w) dis[x] = dis[t] + w; 更新1号点到x的距离

适用环境: 稠密度(点少边多) n >> m
理解:
  1.0 确定原点+初始化操作
  2.0 循环操作 n次
    未标记的点的集合中,筛选出一个距离最短的点  ==>  时间复杂度: n^2
    对筛选出的点进行标记  ==>  时间复杂度: n
    利用筛选出的点对所有点的距离进行更新修改  ==>  时间复杂度: m (共计m条边)
  时间复杂度:  O(n^2)
  PS:标记意味着从原点到该点的最短距离已经确定
  
构建:
  dis[] 为距离 int
    []内为索引, value代表距离
  st[] 为状态 bool
    []内为索引, value代表该点是否已经判断出最短距离
边与点的两种构建方式(有向图)
  二维数组: g[N][N]  ==> 遍历所有结点(结点index)
    []内分别为两点的索引, value代表两点间边的长度(距离)
  邻接表 e[M], ne[M], w[M], h[N]  ==> 遍历结点所在的邻接表(边上结点的索引idx)
    e[M], ne[M], w[M]  
      []内储存边的某点的索引, w的value为该边的权重
    h[N]
      []内储存点的索引, value为该点所在的最后插入边的索引



问题: 每次筛选出最小的距离,亦为筛选出最小的值,可以用堆来实现
方法: STL中优先队列priority-queue + 冗余(取出队头,删除队头 + 添加新元素)  ==>  类似于BFS(宽度优先搜索)

堆优化版Dijkstra算法:
构建:
  单链表
    储存指向 & 权重(边距)
    []为边上结点的索引(idx), value 为权重 or 结点的索引(index)
  优先队列
    储存权重(边距) & 索引(结点index)
  st[] 为状态 bool
    []内为索引, value代表该点是否已经判断出最短距离
    
    
适用环境: 稀密图(点多变少) n << m < n^2
时间复杂度:  O(mlogn)
  筛选出距离最短的点  n
  标记筛选出的点  n
  利用筛选出的点对所有点的距离进行更新修改  mlogm 
    n个元素中修改一个值时间复杂度为logn, m条边,每条边均进行一次
    m<n^2 => mlogm < mlog(n^2) = 2*mlogn ==> mlogn级别
