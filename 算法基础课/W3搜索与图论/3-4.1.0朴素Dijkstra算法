假设: n个点, m条边

朴素Dijstra算法基本步骤:
  1.0 初始化距离,1号点确定为0, 其他点为正无穷
    dis[1] = 0, dis[others] = +++; 
  2.0 循环,每次确定一个距离最小的点
    S为已经确定的最短距离的点的集合
    for(i: 0-n)
      t <== 筛选出不在S中的,距离最近的点
      S <== t  将他加入到集合S中
      用t 来更新所有点的距离
        EG: 1号点 ==> t ==w==> x 
          if(dis[x] > dis[t] + w) dis[x] = dis[t] + w; 更新1号点到x的距离


理解:
  1.0 确定原点+初始化操作
  2.0 循环操作 n次
    未标记的点的集合中,筛选出一个距离最短的点  ==>  时间复杂度: n^2
    对筛选出的点进行标记  ==>  时间复杂度: n
    利用筛选出的点对所有点的距离进行更新修改  ==>  时间复杂度: m (共计m条边)
  时间复杂度:  O(n^2)
  PS:标记意味着从原点到该点的最短距离已经确定
  
构建:
  dis[] 为距离 int
    []内为索引, value代表距离
  g[][] 为边 int
    []内分别为两点的索引, value代表两点间边的长度(距离)
  st[] 为状态 bool
    []内为索引, value代表该点是否已经判断出最短距离



问题: 每次筛选出最小的距离,亦为筛选出最小的值,可以用堆来实现
方法: STL中优先队列priority-queue + 冗余(取出队头,删除队头 + 添加新元素)  ==>  类似于BFS(宽度优先搜索)
  
