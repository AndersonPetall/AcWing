https://www.acwing.com/activity/content/problem/content/909/
https://www.acwing.com/problem/content/848/


树与图的dfs模板
// 需要标记数组st[N],  遍历节点的每个相邻的结点
void dfs(int u) {
    st[u] = true; // 标记一下，记录为已经被搜索过了，下面进行搜索过程
    for (int i = h[u]; i != -1; i = ne[i]) {
        int j = e[i];
        if (!st[j]) {
            dfs(j);
        }
    }
}


问题:
树的重心: 重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心
  如何求得重心  ==>  遍历每个结点,求删除该结点后,每个连通块的点数

核心: 将结点A删除后,连通块的情况
  在树中,删除结点A后,连通块的组成
    结点A上面的连通块
      一个 ==>  该连通块点数 = 树的总结点数 - 以A为根的树的总结点数
    结点A下面的连通块
      当A不为分支结点  一个
      当A为分支结点  两个及以上


思路:
  对一个结点A,遍历出A下面的连通块中的最大值, 然后再和A上面的连通块比较,得出最大值
  再每个结点的最大的连通块点数的集合中,筛选出最小值
    
    
实现:
  ans记录树的重心 中的最小点数的连通块
  res记录删除某结点后的 最大点数的连通块
  sum记录以结点A为树根的结点值
  s记录以当前结点(A的子结点)为根的  结点值   
    通过单链表,递归求解 以结点A为树根的结点值
      若当前子结点B违背遍历,
        s = dfs(B); res = max(res, s); sum += s;
      res = max(res, n - sum); A上面的连通块和下面最大的连通块中比较
      ans = min(ans, res); 在每个结点删除后,最大的连通块的集合中,筛选出最小值
