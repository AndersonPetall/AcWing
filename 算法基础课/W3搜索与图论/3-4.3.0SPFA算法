SPFA算法求最短路     
思想: 当一个点的距离发生变化,其后连接的所有点的距离均发生变化
构建: BFS的思想  ==>  单链表储存结点与对应的边,队列储存距离发生变化的点
  弹出d队头结点,标记修改为false
  遍历队头结点后续所有有连接的点: 利用队头更新结点距离
    若距离需要改变且结点不在队列中(标记显示为false),则更新距离且加入队列标记修改为true
    若距离需要改变且结点已在队列中(标记显示为true), 则仅更新距离
时间复杂度: 一般平均O(m), 最坏O(m*n)  假设: n个点, m条边
SPFA算法 VS Dijkstra算法/Bellman_ford算法
  SPFA算法遍历距离改变的点;Bellman_ford算法遍历所有点. 因此SPFA算法的判断条件为0x3f3f3f3f;Bellman_ford算法的判断条件为0x3f3f3f3f/2
  SPFA算法st[]判断结点是否在队列中,为true后距离依然可以更改;Dijkstra算法st[]判断结点是否已是最近距离,为true后距离确定,不可以更改.
  运用SPFA算法求最短路不可以存在负权回路;运用Bellman_ford算法则可以存在负权回路. 
    ==> SPFA算法会将距离更新的点入队,负权回路会使该回路上的点一直更新形成死循环; Bellman_ford算法有路劲限制,不存在死循环问题.



SPFA算法求判断负环(负权回路)
在求最短路的基础上改进
思想:
  若存在负环,则在更新距离的时候,每遍历一次负环结点距离均会减少  ==>  因此每遍历一次负环该结点距离会改变一次,每改变一次距离意味着该结点会多遍历一次;
  若的权重为正,在更新距离的时候,则遍历该环结点距离会增加  ==>  因此遍历正环该结点的距离不会改变,结点也不会被多遍历一次
构建:  构建cnt[]数组记录路径数,索引为结点,值为到达该结点所用的边数
  所有结点标记为true, 进入队列
  弹出d队头结点,标记修改为false
  遍历队头结点后续所有有连接的点: 利用队头更新结点距离
    若距离需要改变,则该结点路径数在队头的基础上+1  ==>  cnt[j] =  cnt[t] + 1;
      如果不存在负环,则所有结点的路劲均 < n (每个结点只遍历一次)
      若存在负环,则负环的结点的路劲多次循环后会 >= n (负环结点死循环一直遍历)
   
