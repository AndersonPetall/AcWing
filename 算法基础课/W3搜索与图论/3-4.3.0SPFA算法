SPFA算法求最短路     
思想: 当一个点的距离发生变化,其后连接的所有点的距离均发生变化
构建: BFS的思想  ==>  利用队列,将距离发生变化的点入队
        弹出d队头结点,标记为否
        遍历队头结点后续所有有连接的点: 利用队头更新结点距离
          若距离改变且结点不在队列中(标价为否),则更新距离且加入队列标记为真
          若距离改变且结点已在队列中(标记为真), 则仅更新距离
时间复杂度: 一般平均O(m), 最坏O(m*n)  假设: n个点, m条边
SPFA算法 VS Dijkstra算法/Bellman_ford算法
  SPFA算法遍历距离改变的点;Bellman_ford算法遍历所有点. 因此SPFA算法的判断条件为0x3f3f3f3f;Bellman_ford算法的判断条件为0x3f3f3f3f/2
  SPFA算法st[]判断结点是否在队列中,为true后距离依然可以更改;Dijkstra算法st[]判断结点是否已是最近距离,为true后距离确定,不可以更改.
  运用SPFA算法不可以存在负权回路;运用Bellman_ford算法则可以存在负权回路. SPFA算法会将距离更新的点入队,负权回路会使该回路上的点一直更新形成死循环; Bellman_ford算法有路劲限制,不存在死循环问题.



SPFA算法求判断负环
