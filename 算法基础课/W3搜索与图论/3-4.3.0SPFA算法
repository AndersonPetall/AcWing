SPFA算法求最短路     
思想: 当一个点的距离发生变化,其后连接的所有点的距离均发生变化
构建: BFS的思想  ==>  单链表储存结点与对应的边,队列储存距离发生变化的点
  弹出d队头结点,标记修改为false
  遍历队头结点后续所有有连接的点: 利用队头更新结点距离
    若距离改变且结点不在队列中(标记显示为false),则更新距离且加入队列标记修改为true
    若距离改变且结点已在队列中(标记显示为true), 则仅更新距离
时间复杂度: 一般平均O(m), 最坏O(m*n)  假设: n个点, m条边
SPFA算法 VS Dijkstra算法/Bellman_ford算法
  SPFA算法遍历距离改变的点;Bellman_ford算法遍历所有点. 因此SPFA算法的判断条件为0x3f3f3f3f;Bellman_ford算法的判断条件为0x3f3f3f3f/2
  SPFA算法st[]判断结点是否在队列中,为true后距离依然可以更改;Dijkstra算法st[]判断结点是否已是最近距离,为true后距离确定,不可以更改.
  运用SPFA算法求最短路不可以存在负权回路;运用Bellman_ford算法则可以存在负权回路. SPFA算法会将距离更新的点入队,负权回路会使该回路上的点一直更新形成死循环; Bellman_ford算法有路劲限制,不存在死循环问题.



SPFA算法求判断负环(负权回路)
在求最短路的基础上改进
思想:若存在负环,则该负环在跟新点距离的时候会更新距离,每跟新一次距离意味着该结点会多遍历一次; 若该环权重为正,则该环在跟新结点距离的时候不会会更新距离,意味着该结点不会多遍历一次
构建:  所有结点标记为true, 进入队列
  
   
